<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="theme-color" content="#1a2e1a">
<title>Claude Village</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
html, body { width: 100%; height: 100%; overflow: hidden; font-family: -apple-system, 'Segoe UI', Roboto, sans-serif; background: #1a2e1a; color: #fff; }

#canvas { width: 100%; height: 100%; display: block; touch-action: none; }

/* Status bar */
#status { position: fixed; top: 0; left: 0; right: 0; padding: 8px 16px; padding-top: max(8px, env(safe-area-inset-top)); background: rgba(0,0,0,0.6); backdrop-filter: blur(8px); -webkit-backdrop-filter: blur(8px); display: flex; justify-content: space-between; align-items: center; font-size: 13px; z-index: 100; }
#status .title { font-weight: 700; font-size: 15px; }
#status .info { opacity: 0.7; font-size: 11px; }
.conn { display: inline-block; width: 8px; height: 8px; border-radius: 50%; margin-left: 6px; }
.conn.on { background: #4f4; box-shadow: 0 0 6px #4f4; }
.conn.off { background: #f44; }

/* Bottom toolbar */
#toolbar { position: fixed; bottom: 0; left: 0; right: 0; padding: 6px 8px; padding-bottom: max(6px, env(safe-area-inset-bottom)); background: rgba(0,0,0,0.75); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); display: flex; gap: 4px; z-index: 100; }
.tab { flex: 1; text-align: center; padding: 10px 4px; border-radius: 12px; font-size: 12px; font-weight: 600; cursor: pointer; transition: all 0.2s; position: relative; user-select: none; }
.tab:hover, .tab.active { background: rgba(255,255,255,0.15); }
.tab .icon { font-size: 20px; display: block; margin-bottom: 2px; }
.badge { position: absolute; top: 4px; right: 4px; background: #f44; color: #fff; font-size: 10px; font-weight: 700; min-width: 16px; height: 16px; border-radius: 8px; display: flex; align-items: center; justify-content: center; padding: 0 4px; }

/* Panels */
.panel { position: fixed; bottom: 68px; left: 8px; right: 8px; max-height: 50vh; overflow-y: auto; background: rgba(20,30,20,0.92); backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px); border-radius: 16px; padding: 16px; z-index: 99; display: none; border: 1px solid rgba(255,255,255,0.1); }
.panel.show { display: block; animation: slideUp 0.3s ease-out; }
@keyframes slideUp { from { transform: translateY(20px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }

/* Agent card */
.agent-card { display: flex; align-items: center; gap: 10px; padding: 10px; border-radius: 12px; margin-bottom: 8px; cursor: pointer; transition: background 0.2s; }
.agent-card:hover, .agent-card:active { background: rgba(255,255,255,0.08); }
.agent-dot { width: 32px; height: 32px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 14px; font-weight: 700; color: #fff; flex-shrink: 0; }
.agent-info { flex: 1; min-width: 0; }
.agent-name { font-weight: 600; font-size: 14px; }
.agent-role { font-size: 11px; opacity: 0.6; }
.agent-needs { display: flex; gap: 4px; margin-top: 4px; }
.need-bar { flex: 1; height: 4px; border-radius: 2px; background: rgba(255,255,255,0.1); overflow: hidden; }
.need-fill { height: 100%; border-radius: 2px; transition: width 0.5s; }

/* Food grid */
.food-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 8px; }
.food-btn { background: rgba(255,255,255,0.08); border: 2px solid rgba(255,255,255,0.1); border-radius: 12px; padding: 12px 4px; text-align: center; cursor: pointer; transition: all 0.2s; font-size: 24px; user-select: none; }
.food-btn:hover, .food-btn:active, .food-btn.selected { background: rgba(255,255,255,0.2); border-color: #D4AF37; transform: scale(1.05); }
.food-name { font-size: 10px; margin-top: 4px; opacity: 0.7; }
.food-hint { text-align: center; font-size: 12px; opacity: 0.5; margin-top: 12px; }

/* Quick drop button */
.quick-drop { display: block; width: 100%; margin-top: 12px; padding: 14px; border-radius: 12px; border: 2px dashed rgba(212,175,55,0.5); background: rgba(212,175,55,0.1); color: #D4AF37; font-size: 14px; font-weight: 600; cursor: pointer; text-align: center; }
.quick-drop:active { background: rgba(212,175,55,0.3); }

/* Request card */
.req-card { background: rgba(255,255,255,0.06); border-radius: 12px; padding: 12px; margin-bottom: 8px; }
.req-from { font-weight: 600; font-size: 13px; }
.req-msg { font-size: 12px; opacity: 0.8; margin: 6px 0; }
.req-actions { display: flex; gap: 8px; }
.req-btn { flex: 1; padding: 10px; border-radius: 8px; border: none; font-size: 14px; font-weight: 600; cursor: pointer; }
.req-approve { background: #2d8a4e; color: #fff; }
.req-deny { background: #8a2d2d; color: #fff; }
.req-btn:active { transform: scale(0.95); }

/* Event log */
.event { padding: 6px 0; border-bottom: 1px solid rgba(255,255,255,0.05); font-size: 12px; opacity: 0.8; }
.event:last-child { border: none; }
.event-time { font-size: 10px; opacity: 0.5; }

.panel-title { font-size: 16px; font-weight: 700; margin-bottom: 12px; }
.empty-msg { text-align: center; padding: 24px; opacity: 0.4; font-size: 13px; }

/* Food drop mode overlay */
#food-mode { position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(212,175,55,0.9); color: #000; padding: 14px 28px; border-radius: 24px; font-size: 16px; font-weight: 700; z-index: 101; display: none; pointer-events: none; animation: pulse 1.5s ease-in-out infinite; }
@keyframes pulse { 0%,100% { transform: translate(-50%,-50%) scale(1); } 50% { transform: translate(-50%,-50%) scale(1.05); } }

/* Toast notification */
#toast { position: fixed; top: 60px; left: 50%; transform: translateX(-50%); background: rgba(45,138,78,0.95); color: #fff; padding: 10px 20px; border-radius: 20px; font-size: 13px; font-weight: 600; z-index: 200; display: none; pointer-events: none; }
#toast.show { display: block; animation: toastIn 0.3s ease-out; }
@keyframes toastIn { from { opacity: 0; transform: translateX(-50%) translateY(-10px); } to { opacity: 1; transform: translateX(-50%) translateY(0); } }
</style>
</head>
<body>

<canvas id="canvas"></canvas>

<div id="status">
    <div>
        <span class="title">Claude Village</span>
        <span class="conn" id="conn"></span>
    </div>
    <div class="info">
        <span id="tick-info">Tick: 0</span> &middot;
        <span id="period-info">day</span> &middot;
        <span id="sound-btn" onclick="toggleSound()" style="cursor:pointer;font-size:16px;">ğŸ”‡</span>
    </div>
</div>

<div id="food-mode">ğŸ¥™ ×œ×—×¥ ×¢×œ ×”××¤×” ×œ×”×–×¨×™×§ ××•×›×œ!</div>
<div id="toast"></div>

<div id="panel-agents" class="panel">
    <div class="panel-title">ğŸ¦€ ×¡×•×›× ×™×</div>
    <div id="agents-list"></div>
</div>

<div id="panel-food" class="panel">
    <div class="panel-title">ğŸ¥™ ××•×›×œ ×˜×•×¨×§×™</div>
    <div class="food-grid" id="food-grid"></div>
    <div class="food-hint">×‘×—×¨ ××•×›×œ ×•×œ×—×¥ ×¢×œ ×”××¤×”, ××•:</div>
    <button class="quick-drop" id="quick-drop-btn">ğŸ² ×–×¨×•×§ ××•×›×œ ××§×¨××™ ×œ××¨×›×–</button>
</div>

<div id="panel-requests" class="panel">
    <div class="panel-title">ğŸ“‹ ×‘×§×©×•×ª</div>
    <div id="requests-list"></div>
</div>

<div id="panel-events" class="panel">
    <div class="panel-title">ğŸ“œ ××™×¨×•×¢×™×</div>
    <div id="events-list"></div>
</div>

<div id="toolbar">
    <div class="tab" data-panel="agents"><span class="icon">ğŸ¦€</span>×¡×•×›× ×™×</div>
    <div class="tab" data-panel="food"><span class="icon">ğŸ¥™</span>××•×›×œ</div>
    <div class="tab" data-panel="requests"><span class="icon">ğŸ“‹</span>×‘×§×©×•×ª<span class="badge" id="req-badge" style="display:none">0</span></div>
    <div class="tab" data-panel="events"><span class="icon">ğŸ“œ</span>××™×¨×•×¢×™×</div>
</div>

<script>
// ========== STATE ==========
let snapshot = null;
let prevSnapshot = null;
let ws = null;
let connected = false;
let lastSnapshotTime = 0;
let wsMessageCount = 0;
let snapshotCount = 0;

// Interpolated agent positions (smooth movement)
const agentPositions = {};  // id â†’ {startX, startY, targetX, targetY, x, y, moveStart}

// ========== SOUND ENGINE (Web Audio API) ==========
let audioCtx = null;
let soundEnabled = false;
let ambientGain = null;
let sfxGain = null;
let ambientNodes = [];

function initAudio() {
    if (audioCtx) return;
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();

    // Master gains
    ambientGain = audioCtx.createGain();
    ambientGain.gain.value = 0.12;
    ambientGain.connect(audioCtx.destination);

    sfxGain = audioCtx.createGain();
    sfxGain.gain.value = 0.3;
    sfxGain.connect(audioCtx.destination);

    soundEnabled = true;
    startAmbience();
}

function startAmbience() {
    if (!audioCtx || !soundEnabled) return;
    // Gentle wind (filtered noise)
    const bufSize = audioCtx.sampleRate * 4;
    const noiseBuf = audioCtx.createBuffer(1, bufSize, audioCtx.sampleRate);
    const data = noiseBuf.getChannelData(0);
    for (let i = 0; i < bufSize; i++) data[i] = (Math.random() * 2 - 1) * 0.3;
    const noise = audioCtx.createBufferSource();
    noise.buffer = noiseBuf;
    noise.loop = true;
    const windFilter = audioCtx.createBiquadFilter();
    windFilter.type = 'lowpass';
    windFilter.frequency.value = 300;
    windFilter.Q.value = 0.5;
    noise.connect(windFilter);
    windFilter.connect(ambientGain);
    noise.start();
    ambientNodes.push(noise);

    // Bird chirps every few seconds
    scheduleBirdChirp();
}

function scheduleBirdChirp() {
    if (!audioCtx || !soundEnabled) return;
    const delay = 3000 + Math.random() * 8000;
    setTimeout(() => {
        if (!soundEnabled) return;
        playBirdChirp();
        scheduleBirdChirp();
    }, delay);
}

function playBirdChirp() {
    if (!audioCtx || !soundEnabled) return;
    const now = audioCtx.currentTime;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = 'sine';
    // Random bird pitch
    const baseFreq = 1200 + Math.random() * 1800;
    osc.frequency.setValueAtTime(baseFreq, now);
    osc.frequency.linearRampToValueAtTime(baseFreq * (1.1 + Math.random() * 0.4), now + 0.05);
    osc.frequency.linearRampToValueAtTime(baseFreq * 0.9, now + 0.12);
    gain.gain.setValueAtTime(0, now);
    gain.gain.linearRampToValueAtTime(0.08, now + 0.01);
    gain.gain.linearRampToValueAtTime(0, now + 0.15);
    osc.connect(gain);
    gain.connect(ambientGain);
    osc.start(now);
    osc.stop(now + 0.2);
    // Sometimes double chirp
    if (Math.random() < 0.5) {
        const osc2 = audioCtx.createOscillator();
        const gain2 = audioCtx.createGain();
        osc2.type = 'sine';
        osc2.frequency.setValueAtTime(baseFreq * 1.2, now + 0.18);
        osc2.frequency.linearRampToValueAtTime(baseFreq * 1.5, now + 0.25);
        gain2.gain.setValueAtTime(0, now + 0.18);
        gain2.gain.linearRampToValueAtTime(0.06, now + 0.2);
        gain2.gain.linearRampToValueAtTime(0, now + 0.3);
        osc2.connect(gain2);
        gain2.connect(ambientGain);
        osc2.start(now + 0.18);
        osc2.stop(now + 0.35);
    }
}

function playFoodDrop() {
    if (!audioCtx || !soundEnabled) return;
    const now = audioCtx.currentTime;
    // Pleasant "plop" sound
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = 'sine';
    osc.frequency.setValueAtTime(600, now);
    osc.frequency.exponentialRampToValueAtTime(200, now + 0.15);
    gain.gain.setValueAtTime(0.25, now);
    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
    osc.connect(gain);
    gain.connect(sfxGain);
    osc.start(now);
    osc.stop(now + 0.25);
}

function playSpeech() {
    if (!audioCtx || !soundEnabled) return;
    const now = audioCtx.currentTime;
    // Soft "blip" for speech bubbles
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.type = 'triangle';
    osc.frequency.setValueAtTime(800 + Math.random() * 400, now);
    osc.frequency.linearRampToValueAtTime(600, now + 0.06);
    gain.gain.setValueAtTime(0.12, now);
    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
    osc.connect(gain);
    gain.connect(sfxGain);
    osc.start(now);
    osc.stop(now + 0.12);
}

function playEat() {
    if (!audioCtx || !soundEnabled) return;
    const now = audioCtx.currentTime;
    // "Munch" â€” two quick notes
    for (let i = 0; i < 2; i++) {
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = 'square';
        osc.frequency.setValueAtTime(300 + i * 100, now + i * 0.08);
        gain.gain.setValueAtTime(0.08, now + i * 0.08);
        gain.gain.exponentialRampToValueAtTime(0.001, now + i * 0.08 + 0.06);
        osc.connect(gain);
        gain.connect(sfxGain);
        osc.start(now + i * 0.08);
        osc.stop(now + i * 0.08 + 0.08);
    }
}

function toggleSound() {
    if (!audioCtx) {
        initAudio();
        document.getElementById('sound-btn').textContent = 'ğŸ”Š';
        return;
    }
    soundEnabled = !soundEnabled;
    if (soundEnabled) {
        audioCtx.resume();
        ambientGain.gain.value = 0.12;
        startAmbience();
        document.getElementById('sound-btn').textContent = 'ğŸ”Š';
    } else {
        ambientGain.gain.value = 0;
        ambientNodes.forEach(n => { try { n.stop(); } catch(e) {} });
        ambientNodes = [];
        document.getElementById('sound-btn').textContent = 'ğŸ”‡';
    }
}

// Camera
let camX = 0, camY = 0, camZoom = 0.7;  // start zoomed out more to see everything
let dragging = false, dragStartX = 0, dragStartY = 0, camStartX = 0, camStartY = 0;
let dragDist = 0;  // track drag distance to distinguish tap from drag
let pinchStartDist = 0, pinchStartZoom = 1;

// Food dropping
let foodMode = false;
let selectedFood = null;

// Turkish foods
const FOODS = [
    {emoji:"ğŸ¥™", name:"×“×•× ×¨"}, {emoji:"ğŸ–", name:"××™×¡×§× ×“×¨"}, {emoji:"ğŸ¥Ÿ", name:"×× ×˜×™"},
    {emoji:"ğŸ«“", name:"×œ×—××’×³×•×Ÿ"}, {emoji:"ğŸ¢", name:"×©×™×© ×§×‘×‘"}, {emoji:"ğŸ§†", name:"×›×•×¤×ª×”"},
    {emoji:"ğŸ«•", name:"×¤×™×“×”"}, {emoji:"ğŸš", name:"×¤×™×œ××£"}, {emoji:"ğŸ¬", name:"×‘××§×œ×•×•×”"},
    {emoji:"ğŸ«–", name:"×¦×³××™"}, {emoji:"â˜•", name:"×§×¤×” ×˜×•×¨×§×™"}
];

const NEED_COLORS = { hunger: "#ff6b6b", social: "#4ecdc4", creativity: "#a855f7", workDrive: "#f59e0b", rest: "#60a5fa" };

// ========== CANVAS ==========
const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d');
let W, H;

function resize() {
    canvas.width = window.innerWidth * devicePixelRatio;
    canvas.height = window.innerHeight * devicePixelRatio;
    W = window.innerWidth;
    H = window.innerHeight;
}
window.addEventListener('resize', resize);
resize();

// ========== SMOOTH AGENT MOVEMENT ==========
const POLL_INTERVAL = 2000;  // ms between snapshots

function updateAgentInterpolation() {
    if (!snapshot) return;
    const now = Date.now();

    // Detect new speech bubbles and eat events for sound effects
    if (prevSnapshot && soundEnabled) {
        for (const a of snapshot.agents) {
            const prev = prevSnapshot.agents.find(p => p.id === a.id);
            if (prev) {
                if (a.currentSpeech && a.currentSpeech !== prev.currentSpeech) {
                    playSpeech();
                }
                if (a.state === 'eating' && prev.state !== 'eating') {
                    playEat();
                }
            }
        }
    }

    for (const a of snapshot.agents) {
        if (!agentPositions[a.id]) {
            // First time â€” place immediately
            agentPositions[a.id] = {
                startX: a.position.x, startY: a.position.y,
                targetX: a.position.x, targetY: a.position.y,
                x: a.position.x, y: a.position.y,
                moveStart: now
            };
        } else {
            const p = agentPositions[a.id];
            // New target arrived â€” start interpolating from current visual position
            p.startX = p.x;
            p.startY = p.y;
            p.targetX = a.position.x;
            p.targetY = a.position.y;
            p.moveStart = now;
        }
    }
}

function interpolateAgents() {
    const now = Date.now();
    for (const id in agentPositions) {
        const p = agentPositions[id];
        // Time-based interpolation: spread movement over POLL_INTERVAL
        let t = (now - p.moveStart) / POLL_INTERVAL;
        t = Math.min(t, 1);  // clamp to [0,1]
        // Ease-in-out for natural movement
        t = t < 0.5 ? 2 * t * t : 1 - (-2 * t + 2) * (-2 * t + 2) / 2;
        p.x = p.startX + (p.targetX - p.startX) * t;
        p.y = p.startY + (p.targetY - p.startY) * t;
    }
}

// ========== DRAWING ==========
function draw() {
    ctx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);

    // Interpolate agent positions every frame
    interpolateAgents();

    // Background based on day period
    let bgColor = '#2a4a2a';
    if (snapshot) {
        switch (snapshot.dayPeriod) {
            case 'morning': bgColor = '#3a5a3a'; break;
            case 'day': bgColor = '#2a4a2a'; break;
            case 'evening': bgColor = '#2a3040'; break;
            case 'night': bgColor = '#151e25'; break;
        }
    }
    ctx.fillStyle = bgColor;
    ctx.fillRect(0, 0, W, H);

    ctx.save();
    ctx.translate(W / 2 + camX, H / 2 - camY);
    ctx.scale(camZoom, camZoom);

    if (snapshot) {
        drawGround();
        drawHouses(snapshot.houses);
        drawStructures(snapshot.structures);
        drawFoods(snapshot.foods);
        drawAgents(snapshot.agents);
    }

    // Food mode crosshair
    if (foodMode) {
        ctx.strokeStyle = 'rgba(212,175,55,0.6)';
        ctx.lineWidth = 1.5;
        ctx.setLineDash([8, 4]);
        ctx.beginPath();
        ctx.moveTo(-600, 0); ctx.lineTo(600, 0);
        ctx.moveTo(0, -600); ctx.lineTo(0, 600);
        ctx.stroke();
        ctx.setLineDash([]);
    }

    ctx.restore();

    // Connection status text if not connected
    if (!connected && !snapshot) {
        ctx.fillStyle = '#fff';
        ctx.font = '16px -apple-system, sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('××ª×—×‘×¨ ×œ×›×¤×¨...', W / 2, H / 2);
    }

    // Debug: show WS message count bottom-left
    ctx.fillStyle = 'rgba(255,255,255,0.4)';
    ctx.font = '10px monospace';
    ctx.textAlign = 'left';
    ctx.fillText(`snap:${snapshotCount} poll:${pollingActive?'on':'off'} agents:${snapshot ? snapshot.agents.length : 0} zoom:${camZoom.toFixed(1)}`, 8, H - 8);

    requestAnimationFrame(draw);
}

function drawGround() {
    // Grass texture
    ctx.fillStyle = 'rgba(50,100,50,0.3)';
    for (let x = -500; x < 500; x += 40) {
        for (let y = -500; y < 500; y += 40) {
            ctx.fillRect(x, -y, 2, 8);
            ctx.fillRect(x + 20, -y + 15, 2, 6);
        }
    }

    // Paths (light brown roads)
    ctx.fillStyle = 'rgba(160,130,90,0.4)';
    ctx.fillRect(-500, -8, 1000, 16);
    ctx.fillRect(-8, -500, 16, 1000);

    // Diagonal paths
    ctx.save();
    ctx.rotate(Math.PI / 4);
    ctx.fillRect(-400, -6, 800, 12);
    ctx.restore();
    ctx.save();
    ctx.rotate(-Math.PI / 4);
    ctx.fillRect(-400, -6, 800, 12);
    ctx.restore();

    // Center fountain
    ctx.beginPath();
    ctx.arc(0, 0, 30, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(60,140,200,0.4)';
    ctx.fill();
    ctx.strokeStyle = 'rgba(100,160,220,0.6)';
    ctx.lineWidth = 2;
    ctx.stroke();

    // Fountain sparkle
    const t = Date.now() * 0.003;
    for (let i = 0; i < 5; i++) {
        const angle = t + i * Math.PI * 0.4;
        const r = 12 + Math.sin(t * 2 + i) * 5;
        ctx.fillStyle = 'rgba(150,200,255,0.5)';
        ctx.beginPath();
        ctx.arc(Math.cos(angle) * r, Math.sin(angle) * r, 1.5, 0, Math.PI * 2);
        ctx.fill();
    }

    // Fountain center
    ctx.beginPath();
    ctx.arc(0, 0, 8, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(80,80,80,0.6)';
    ctx.fill();

    // Trees
    const trees = [[-300, 0], [300, 0], [0, 300], [0, -300], [-250, 250], [250, -250], [250, 250], [-250, -250]];
    for (const [tx, ty] of trees) {
        ctx.fillStyle = 'rgba(40,80,30,0.6)';
        ctx.beginPath();
        ctx.arc(tx, -ty, 15, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = 'rgba(60,120,40,0.5)';
        ctx.beginPath();
        ctx.arc(tx - 3, -ty - 3, 12, 0, Math.PI * 2);
        ctx.fill();
        // Trunk
        ctx.fillStyle = 'rgba(100,70,40,0.7)';
        ctx.fillRect(tx - 2, -ty + 10, 4, 8);
    }
}

function drawHouses(houses) {
    for (const h of houses) {
        const x = h.position.x;
        const y = -h.position.y;

        // House shadow
        ctx.fillStyle = 'rgba(0,0,0,0.2)';
        ctx.fillRect(x - 38, y + 4, 76, 56);

        // Walls
        ctx.fillStyle = h.wallColor;
        ctx.fillRect(x - 35, y, 70, 50);
        ctx.strokeStyle = 'rgba(255,255,255,0.15)';
        ctx.lineWidth = 1;
        ctx.strokeRect(x - 35, y, 70, 50);

        // Roof
        ctx.fillStyle = h.roofColor;
        ctx.beginPath();
        ctx.moveTo(x - 42, y);
        ctx.lineTo(x, y - 25);
        ctx.lineTo(x + 42, y);
        ctx.closePath();
        ctx.fill();

        // Door
        ctx.fillStyle = 'rgba(100,70,40,0.8)';
        ctx.fillRect(x - 8, y + 25, 16, 25);

        // Window glow
        const isNight = snapshot && (snapshot.dayPeriod === 'night' || snapshot.dayPeriod === 'evening');
        ctx.fillStyle = isNight ? 'rgba(255,230,100,0.7)' : 'rgba(150,180,220,0.3)';
        ctx.fillRect(x - 25, y + 10, 12, 12);
        ctx.fillRect(x + 13, y + 10, 12, 12);

        // Emoji
        ctx.font = '20px serif';
        ctx.textAlign = 'center';
        ctx.fillText(h.emoji, x, y - 30);

        // Name
        ctx.font = '10px -apple-system, sans-serif';
        ctx.fillStyle = '#fff';
        ctx.textAlign = 'center';
        ctx.fillText(h.name, x, y + 64);
    }
}

function drawStructures(structures) {
    const STRUCT_EMOJIS = {
        '×©×œ×˜': 'ğŸª§', '×¡×¤×¡×œ': 'ğŸª‘', '×’×Ÿ ×¤×¨×—×™×': 'ğŸŒ¸', '×¤× ×¡': 'ğŸ®',
        '×’×“×¨': 'ğŸ—ï¸', '×’×“×¨ ×“×§×•×¨×˜×™×‘×™×ª': 'ğŸ‹', '×’×©×¨': 'ğŸŒ‰', '×‘××¨': 'â›²',
        '×“×¨×š': 'ğŸ›¤ï¸', '×œ×•×— ××•×“×¢×•×ª': 'ğŸ“Œ', '×¢××“×ª ×‘×“×™×§×”': 'ğŸ”', '×¡×¤×¡×œ ×ª×¦×¤×™×ª': 'ğŸª‘',
        '××‘× ×”': 'ğŸ '
    };
    for (const s of structures) {
        const x = s.position.x;
        const y = -s.position.y;
        const emoji = STRUCT_EMOJIS[s.type] || 'ğŸ ';

        ctx.font = '22px serif';
        ctx.textAlign = 'center';
        ctx.fillText(emoji, x, y + 6);

        ctx.font = '8px -apple-system, sans-serif';
        ctx.fillStyle = 'rgba(255,255,255,0.5)';
        ctx.fillText(s.type, x, y + 20);
    }
}

function drawFoods(foods) {
    const t = Date.now() * 0.004;
    for (const f of foods) {
        const x = f.position.x;
        const y = -f.position.y;

        // Glow pulse
        if (!f.isBeingEaten) {
            const glowSize = 14 + Math.sin(t) * 3;
            ctx.beginPath();
            ctx.arc(x, y, glowSize, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(255,200,50,0.15)';
            ctx.fill();
        }

        const bounce = f.isBeingEaten ? 0 : Math.sin(t * 2) * 2;
        ctx.font = f.isBeingEaten ? '14px serif' : '22px serif';
        ctx.textAlign = 'center';
        ctx.globalAlpha = f.isBeingEaten ? 0.4 : 1;
        ctx.fillText(f.emoji, x, y + 6 + bounce);
        ctx.globalAlpha = 1;

        ctx.font = '8px -apple-system, sans-serif';
        ctx.fillStyle = 'rgba(255,255,255,0.7)';
        ctx.fillText(f.name, x, y + 22);
    }
}

function drawAgents(agents) {
    const t = Date.now() * 0.003;
    for (const a of agents) {
        // Use interpolated position for smooth movement
        const interp = agentPositions[a.id];
        const x = interp ? interp.x : a.position.x;
        const y = interp ? -interp.y : -a.position.y;
        const color = a.badgeColor;

        // Walking animation: leg wiggle and body bob
        const isMoving = interp && (Math.abs(interp.targetX - interp.x) > 1 || Math.abs(interp.targetY - interp.y) > 1);
        const walkBob = isMoving ? Math.sin(t * 8) * 2 : Math.sin(t * 1.5) * 1;
        const legWiggle = isMoving ? Math.sin(t * 10) * 0.3 : 0;

        // Shadow
        ctx.beginPath();
        ctx.ellipse(x, y + 16, 14, 4, 0, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(0,0,0,0.25)';
        ctx.fill();

        // Body (crab-like oval) with bob
        const bodyY = y + walkBob;
        ctx.beginPath();
        ctx.ellipse(x, bodyY, 14, 10, 0, 0, Math.PI * 2);
        ctx.fillStyle = color;
        ctx.fill();
        ctx.strokeStyle = 'rgba(0,0,0,0.3)';
        ctx.lineWidth = 1.5;
        ctx.stroke();

        // Eye stalks + eyes
        ctx.fillStyle = color;
        ctx.fillRect(x - 5, bodyY - 12, 2, 5);
        ctx.fillRect(x + 3, bodyY - 12, 2, 5);
        ctx.fillStyle = '#fff';
        ctx.beginPath(); ctx.arc(x - 4, bodyY - 13, 3.5, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.arc(x + 4, bodyY - 13, 3.5, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = '#000';
        // Pupils look toward movement direction
        const px = isMoving ? Math.sign(interp.targetX - interp.x) * 1 : 0;
        ctx.beginPath(); ctx.arc(x - 4 + px, bodyY - 13, 1.5, 0, Math.PI * 2); ctx.fill();
        ctx.beginPath(); ctx.arc(x + 4 + px, bodyY - 13, 1.5, 0, Math.PI * 2); ctx.fill();

        // Claws with animation
        ctx.save();
        ctx.strokeStyle = color;
        ctx.lineWidth = 2.5;
        // Left claw
        ctx.save();
        ctx.translate(x - 14, bodyY - 2);
        ctx.rotate(legWiggle);
        ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(-7, -6); ctx.lineTo(-3, -2); ctx.lineTo(-7, 2); ctx.stroke();
        ctx.restore();
        // Right claw
        ctx.save();
        ctx.translate(x + 14, bodyY - 2);
        ctx.rotate(-legWiggle);
        ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(7, -6); ctx.lineTo(3, -2); ctx.lineTo(7, 2); ctx.stroke();
        ctx.restore();
        ctx.restore();

        // Legs with animation
        ctx.strokeStyle = color;
        ctx.lineWidth = 1.5;
        for (let i = 0; i < 3; i++) {
            const ly = bodyY - 4 + i * 5;
            const lw = Math.sin(t * 10 + i) * (isMoving ? 3 : 0);
            ctx.beginPath(); ctx.moveTo(x - 13, ly); ctx.lineTo(x - 20, ly + 4 + lw); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(x + 13, ly); ctx.lineTo(x + 20, ly + 4 - lw); ctx.stroke();
        }

        // Badge on body
        ctx.beginPath();
        ctx.arc(x, bodyY, 5, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255,255,255,0.9)';
        ctx.fill();
        ctx.font = 'bold 6px -apple-system, sans-serif';
        ctx.fillStyle = color;
        ctx.textAlign = 'center';
        ctx.fillText(a.name.charAt(0), x, bodyY + 2.5);

        // Name label
        ctx.font = '9px -apple-system, sans-serif';
        const nameW = ctx.measureText(a.name).width + 10;
        ctx.fillStyle = color + 'BB';
        roundRect(ctx, x - nameW / 2, y + 16, nameW, 15, 5);
        ctx.fill();
        ctx.fillStyle = '#fff';
        ctx.textAlign = 'center';
        ctx.fillText(a.name, x, y + 27);

        // Mood emoji
        ctx.font = '11px serif';
        ctx.fillText(a.moodEmoji, x + 20, bodyY - 6);

        // State indicator
        const stateEmojis = { work: 'ğŸ’»', build: 'ğŸ”¨', eat: 'ğŸ½ï¸', rest: 'ğŸ’¤', socialize: 'ğŸ’¬', explore: 'ğŸš¶', request: 'ğŸ“‹' };
        const stateEmoji = stateEmojis[a.state];
        if (stateEmoji && a.state !== 'idle') {
            ctx.font = '9px serif';
            ctx.fillText(stateEmoji, x - 18, bodyY - 6);
        }

        // Speech bubble
        if (a.currentSpeech) {
            drawSpeechBubble(x, bodyY - 26, a.currentSpeech, color);
        }
    }
}

function drawSpeechBubble(x, y, text, color) {
    ctx.font = '10px -apple-system, sans-serif';
    const displayText = text.length > 30 ? text.substring(0, 30) + '...' : text;
    const metrics = ctx.measureText(displayText);
    const w = Math.min(metrics.width + 18, 170);
    const h = 24;

    // Bubble background
    ctx.fillStyle = 'rgba(255,255,255,0.92)';
    roundRect(ctx, x - w / 2, y - h - 8, w, h, 10);
    ctx.fill();
    ctx.strokeStyle = color + '66';
    ctx.lineWidth = 1;
    roundRect(ctx, x - w / 2, y - h - 8, w, h, 10);
    ctx.stroke();

    // Pointer
    ctx.fillStyle = 'rgba(255,255,255,0.92)';
    ctx.beginPath();
    ctx.moveTo(x - 5, y - 8);
    ctx.lineTo(x, y - 2);
    ctx.lineTo(x + 5, y - 8);
    ctx.fill();

    // Text
    ctx.fillStyle = '#222';
    ctx.textAlign = 'center';
    ctx.fillText(displayText, x, y - h + 9);
}

function roundRect(ctx, x, y, w, h, r) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.lineTo(x + w - r, y);
    ctx.quadraticCurveTo(x + w, y, x + w, y + r);
    ctx.lineTo(x + w, y + h - r);
    ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
    ctx.lineTo(x + r, y + h);
    ctx.quadraticCurveTo(x, y + h, x, y + h - r);
    ctx.lineTo(x, y + r);
    ctx.quadraticCurveTo(x, y, x + r, y);
    ctx.closePath();
}

// ========== TOAST ==========
function showToast(msg) {
    const toast = document.getElementById('toast');
    toast.textContent = msg;
    toast.className = 'show';
    clearTimeout(toast._timer);
    toast._timer = setTimeout(() => { toast.className = ''; }, 2000);
}

// ========== CAMERA CONTROLS ==========

// Mouse drag
canvas.addEventListener('mousedown', e => {
    dragging = true;
    dragDist = 0;
    dragStartX = e.clientX;
    dragStartY = e.clientY;
    camStartX = camX;
    camStartY = camY;
});
canvas.addEventListener('mousemove', e => {
    if (!dragging) return;
    const dx = e.clientX - dragStartX;
    const dy = e.clientY - dragStartY;
    dragDist = Math.hypot(dx, dy);
    camX = camStartX + dx;
    camY = camStartY - dy;
});
canvas.addEventListener('mouseup', e => {
    const wasDrag = dragDist > 5;
    dragging = false;
    // If barely moved and in food mode â†’ drop food
    if (!wasDrag && foodMode) {
        dropFoodAt(e.clientX, e.clientY);
    }
});

// Mouse wheel zoom
canvas.addEventListener('wheel', e => {
    e.preventDefault();
    const delta = e.deltaY > 0 ? 0.9 : 1.1;
    camZoom = Math.max(0.2, Math.min(3, camZoom * delta));
}, { passive: false });

// Touch pan & pinch zoom
let lastTouchPos = null;
canvas.addEventListener('touchstart', e => {
    e.preventDefault();
    const ts = Array.from(e.touches);
    if (ts.length === 1) {
        dragging = true;
        dragDist = 0;
        dragStartX = ts[0].clientX;
        dragStartY = ts[0].clientY;
        camStartX = camX;
        camStartY = camY;
        lastTouchPos = { x: ts[0].clientX, y: ts[0].clientY };
    } else if (ts.length === 2) {
        dragging = false;
        pinchStartDist = Math.hypot(ts[1].clientX - ts[0].clientX, ts[1].clientY - ts[0].clientY);
        pinchStartZoom = camZoom;
    }
}, { passive: false });

canvas.addEventListener('touchmove', e => {
    e.preventDefault();
    const ts = Array.from(e.touches);
    if (ts.length === 1 && dragging) {
        const dx = ts[0].clientX - dragStartX;
        const dy = ts[0].clientY - dragStartY;
        dragDist = Math.hypot(dx, dy);
        camX = camStartX + dx;
        camY = camStartY - dy;
        lastTouchPos = { x: ts[0].clientX, y: ts[0].clientY };
    } else if (ts.length === 2) {
        const dist = Math.hypot(ts[1].clientX - ts[0].clientX, ts[1].clientY - ts[0].clientY);
        camZoom = Math.max(0.2, Math.min(3, pinchStartZoom * (dist / pinchStartDist)));
    }
}, { passive: false });

canvas.addEventListener('touchend', e => {
    e.preventDefault();
    const wasDrag = dragDist > 10;
    dragging = false;
    // Single tap (barely moved) in food mode â†’ drop food
    if (e.touches.length === 0 && !wasDrag && foodMode && lastTouchPos) {
        dropFoodAt(lastTouchPos.x, lastTouchPos.y);
    }
    lastTouchPos = null;
}, { passive: false });

// ========== FOOD DROP ==========
function dropFoodAt(screenX, screenY) {
    const worldX = (screenX - W / 2 - camX) / camZoom;
    const worldY = -(screenY - H / 2 + camY) / camZoom;

    if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ action: 'food', x: worldX, y: worldY }));
    } else {
        fetch('/api/food', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ x: worldX, y: worldY })
        });
    }

    showToast('ğŸ¥™ ××•×›×œ × ×–×¨×§!');
    playFoodDrop();
    foodMode = false;
    selectedFood = null;
    document.getElementById('food-mode').style.display = 'none';
    document.querySelectorAll('.food-btn').forEach(b => b.classList.remove('selected'));
}

function quickDropFood() {
    // Drop random food near center
    const x = (Math.random() - 0.5) * 200;
    const y = (Math.random() - 0.5) * 200;
    if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ action: 'food', x, y }));
    } else {
        fetch('/api/food', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ x, y })
        });
    }
    showToast('ğŸ¥™ ××•×›×œ × ×–×¨×§ ×œ××¨×›×– ×”×›×¤×¨!');
    playFoodDrop();
}

// ========== PANELS ==========

let activePanel = null;

document.querySelectorAll('.tab').forEach(tab => {
    tab.addEventListener('click', () => {
        const panel = tab.dataset.panel;
        document.querySelectorAll('.panel').forEach(p => p.classList.remove('show'));
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));

        if (activePanel === panel) {
            activePanel = null;
            return;
        }

        activePanel = panel;
        tab.classList.add('active');
        document.getElementById('panel-' + panel).classList.add('show');
    });
});

// Build food grid
const foodGrid = document.getElementById('food-grid');
FOODS.forEach(f => {
    const btn = document.createElement('div');
    btn.className = 'food-btn';
    btn.innerHTML = `${f.emoji}<div class="food-name">${f.name}</div>`;
    btn.addEventListener('click', () => {
        document.querySelectorAll('.food-btn').forEach(b => b.classList.remove('selected'));
        btn.classList.add('selected');
        selectedFood = f;
        foodMode = true;
        document.getElementById('food-mode').style.display = 'block';
        // Close panel
        document.querySelectorAll('.panel').forEach(p => p.classList.remove('show'));
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        activePanel = null;
    });
    foodGrid.appendChild(btn);
});

// Quick drop button
document.getElementById('quick-drop-btn').addEventListener('click', () => {
    quickDropFood();
    document.querySelectorAll('.panel').forEach(p => p.classList.remove('show'));
    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
    activePanel = null;
});

function updateAgentsPanel(agents) {
    const list = document.getElementById('agents-list');
    if (!agents) return;
    list.innerHTML = agents.map(a => {
        const needs = a.needs || {};
        const needBars = Object.entries(needs).map(([k, v]) => {
            const color = NEED_COLORS[k] || '#888';
            const label = {hunger:'×¨×¢×‘',social:'×—×‘×¨×ª×™',creativity:'×™×¦×™×¨×ª×™×•×ª',workDrive:'×¢×‘×•×“×”',rest:'×× ×•×—×”'}[k] || k;
            return `<div class="need-bar" title="${label}: ${Math.round(v*100)}%"><div class="need-fill" style="width:${v*100}%;background:${color}"></div></div>`;
        }).join('');
        const goalHeb = {idle:'×××ª×™×Ÿ',eat:'××•×›×œ',socialize:'××“×‘×¨',work:'×¢×•×‘×“',build:'×‘×•× ×”',rest:'× ×—',explore:'××˜×™×™×œ',request:'××‘×§×©'}[a.state] || a.currentGoal;
        return `
        <div class="agent-card" onclick="focusAgent('${a.id}')">
            <div class="agent-dot" style="background:${a.badgeColor}">${a.name.charAt(0)}</div>
            <div class="agent-info">
                <div class="agent-name">${a.name} ${a.moodEmoji}</div>
                <div class="agent-role">${a.role} Â· ${goalHeb}</div>
                <div class="agent-needs">${needBars}</div>
            </div>
        </div>`;
    }).join('');
}

function focusAgent(id) {
    if (!snapshot) return;
    const agent = snapshot.agents.find(a => a.id === id);
    if (agent) {
        const p = agentPositions[id] || agent.position;
        camX = -p.x * camZoom;
        camY = p.y * camZoom;
        if (camZoom < 1) camZoom = 1.2;
    }
    // Close panel
    document.querySelectorAll('.panel').forEach(p => p.classList.remove('show'));
    document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
    activePanel = null;
}

function updateRequestsPanel(requests) {
    const list = document.getElementById('requests-list');
    const badge = document.getElementById('req-badge');

    if (!requests || requests.length === 0) {
        list.innerHTML = '<div class="empty-msg">××™×Ÿ ×‘×§×©×•×ª ×××ª×™× ×•×ª ğŸ‰</div>';
        badge.style.display = 'none';
        return;
    }

    badge.style.display = 'flex';
    badge.textContent = requests.length;

    list.innerHTML = requests.map(r => `
        <div class="req-card">
            <div class="req-from">${r.fromName} Â· ${typeEmoji(r.type)}</div>
            <div class="req-msg">${r.message}</div>
            <div class="req-actions">
                <button class="req-btn req-approve" onclick="approveReq('${r.id}')">âœ… ××™×©×•×¨</button>
                <button class="req-btn req-deny" onclick="denyReq('${r.id}')">âŒ ×“×—×™×™×”</button>
            </div>
        </div>
    `).join('');
}

function typeEmoji(type) {
    return { food: 'ğŸ¥™', buildPermission: 'ğŸ”¨', tool: 'ğŸ”§', vacation: 'ğŸ–ï¸', raise: 'ğŸ’°', general: 'ğŸ“‹' }[type] || 'ğŸ“‹';
}

function approveReq(id) {
    if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ action: 'approve', id }));
    } else {
        fetch(`/api/requests/${id}/approve`, { method: 'POST' });
    }
    showToast('âœ… ×‘×§×©×” ××•×©×¨×”!');
}

function denyReq(id) {
    if (ws && ws.readyState === WebSocket.OPEN) {
        ws.send(JSON.stringify({ action: 'deny', id }));
    } else {
        fetch(`/api/requests/${id}/deny`, { method: 'POST' });
    }
    showToast('âŒ ×‘×§×©×” × ×“×—×ª×”');
}

function updateEventsPanel(events) {
    const list = document.getElementById('events-list');
    if (!events || events.length === 0) {
        list.innerHTML = '<div class="empty-msg">××™×Ÿ ××™×¨×•×¢×™× ×¢×“×™×™×Ÿ</div>';
        return;
    }
    list.innerHTML = events.slice().reverse().map(e => {
        const time = new Date(e.timestamp * 1000).toLocaleTimeString('he-IL', { hour: '2-digit', minute: '2-digit' });
        return `<div class="event"><span class="event-time">${time}</span> ${e.message}</div>`;
    }).join('');
}

// ========== WEBSOCKET + POLLING FALLBACK ==========

let pingInterval = null;
let pollingInterval = null;
let pollingActive = false;

function connectWS() {
    const proto = location.protocol === 'https:' ? 'wss:' : 'ws:';
    ws = new WebSocket(`${proto}//${location.host}/ws`);

    ws.onopen = () => {
        connected = true;
        document.getElementById('conn').className = 'conn on';
        // Send periodic pings to keep connection alive through Railway proxy
        if (pingInterval) clearInterval(pingInterval);
        pingInterval = setInterval(() => {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ action: 'ping' }));
            }
        }, 5000);
    };

    ws.onmessage = (e) => {
        try {
            const data = JSON.parse(e.data);
            // Ignore control frames (pong, etc)
            if (data.action) return;
            // Only accept real snapshots (must have agents array)
            if (!data.agents) return;
            prevSnapshot = snapshot;
            snapshot = data;
            lastSnapshotTime = Date.now();
            snapshotCount++;
            updateAgentInterpolation();
            updateUI();
            // WS is working â€” stop polling if active
            if (pollingActive) {
                clearInterval(pollingInterval);
                pollingActive = false;
            }
        } catch (err) {
            console.error('Parse error:', err);
        }
    };

    ws.onclose = () => {
        connected = false;
        document.getElementById('conn').className = 'conn off';
        if (pingInterval) clearInterval(pingInterval);
        setTimeout(connectWS, 3000);
        // Start polling when WS drops
        if (!pollingActive) startPolling();
    };

    ws.onerror = () => { ws.close(); };
}

// Fallback: if no real snapshots after 8 seconds, poll via HTTP
function checkWSAndFallback() {
    setTimeout(() => {
        if (snapshotCount === 0 && !pollingActive) {
            startPolling();
        }
    }, 8000);
}

function startPolling() {
    if (pollingActive) return;
    pollingActive = true;
    document.getElementById('conn').className = 'conn on';  // show green â€” polling works
    pollingInterval = setInterval(async () => {
        try {
            const data = await fetch('/api/snapshot').then(r => r.json());
            if (!data.agents) return;  // safety check
            prevSnapshot = snapshot;
            snapshot = data;
            lastSnapshotTime = Date.now();
            snapshotCount++;
            updateAgentInterpolation();
            updateUI();
        } catch (e) {
            document.getElementById('conn').className = 'conn off';
        }
    }, 2000);
}

function updateUI() {
    if (!snapshot) return;
    document.getElementById('tick-info').textContent = `Tick: ${snapshot.tick}`;
    document.getElementById('period-info').textContent = {morning:'ğŸŒ… ×‘×•×§×¨', day:'â˜€ï¸ ×™×•×', evening:'ğŸŒ† ×¢×¨×‘', night:'ğŸŒ™ ×œ×™×œ×”'}[snapshot.dayPeriod] || snapshot.dayPeriod;

    updateAgentsPanel(snapshot.agents);
    updateRequestsPanel(snapshot.pendingRequests);
    updateEventsPanel(snapshot.recentEvents);
}

// ========== INIT ==========
fetch('/api/snapshot')
    .then(r => r.json())
    .then(data => {
        snapshot = data;
        updateAgentInterpolation();
        // Set initial positions immediately (no interpolation on load)
        for (const a of data.agents) {
            if (agentPositions[a.id]) {
                const p = agentPositions[a.id];
                p.x = p.startX = p.targetX = a.position.x;
                p.y = p.startY = p.targetY = a.position.y;
            }
        }
        updateUI();
    })
    .catch(() => {});

connectWS();
checkWSAndFallback();
requestAnimationFrame(draw);
</script>
</body>
</html>
